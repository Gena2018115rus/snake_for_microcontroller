#define F_CPU 16000000UL   // частота 16 MHz
#include <avr/io.h>        // используем стандартную библиотеку (для языка Си) для данного микроконтроллера (Atmega328P)
#include <util/delay.h>    // delay.h для функции _delay_ms()
#include <avr/interrupt.h> // interrupt.h для макроса ISR, он нужен, чтобы создавать обработчики прерываний
#include <stdlib.h>        // stdlib.h для функции rand(), а ней реализован простейший алгоритм генерации (псевдо)случайных чисел
#define TRUE 1
#define FALSE 0            // некоторе макросы, чтобы в коде было меньше так называемых магических констант
#define WIDTH 8
#define HEIGHT 8

typedef struct             // часть кода этой змейки я взял из своего приложения для windows,
{                          // там я использовал тип COORD из windows.h. Для своего удобства называю
	unsigned char X, Y;    // структуру и её члены теми же именами, однако меняю тип на unsigned char
} COORD;                   // т.к. он требует меньше памяти (можно было бы обойтись битовыми полями,
                           // что ещё в пару раз уменьшило бы потребление памяти, но время доступа к ним больше, а памяти и так хватает)

#define G2R2_TYPE COORD      // тут подключаю свой файлик с четырьмя функциями для работы с массивами,
#include "Gena2018115rus2.c" // он требует объявить макрос G2R2_TYPE в котором будет имя типа структур, из которых будут массивы

// массив body будет хранить координаты змейки:
// пусть голова - элемент №0, первая клетка тела - элемент №1....
// каждый элемент массива хранит X и Y соответствующей клетки тела
// размер массива соответствует количеству клеток, составляющих поле
// в массив сразу записаны начальные координаты змейки
// явно не указанные координаты устанавливаются в 0, в соответствии со стандартом языка Си
// чтобы подчеркнуть, что произойдёт неявная инициализация, в конце перечисления оставлена запятая
COORD body[WIDTH * HEIGHT] = {{4, 3}, {3, 3}, {2, 3}, };

// т.к. поле 8 * 8, длина змейки не превысит 64 - тип char (-128 - 127)
// а т.к. лучше использовать беззнаковый тип - unsigned char (0 - 255)
unsigned char length = 3; // стартовая длина = 3

// эта переменная будет хранить направление змейки:
// 0 - вправо, 1 - вверх, 2 - влево, 3 - вниз
// когда писал, enum не использовал, переписывать не стал
unsigned char direction = 0; // стартовое направление - вправо

// last_pop хранит координаты конца хвоста в предыдущем кадре, на это место добавляется клетка тела при съедании яблока
COORD last_pop = {1, 3}; // на всякий случай инициализирую

// key_pressed хранит, повернула ли змейка после последнего сдвига, это надо, чтобы нельзя было повернуть два раза между сдвигами
// (чтобы отменить поворот или повернуть на 180 градусов(случайно))
unsigned char key_pressed = FALSE; // со старта = ложь, естественно

// dead установится в, так сказать, правду, когда змейка умрёт(врежется в себя, в данном случае); это надо, чтобы остановить движение
unsigned char dead = FALSE;

// apple хранит координаты яблока; на всякий случай инициализирую
COORD apple = {2, 2};

// ISR - "функция" обработки прерывания                                               (то, что я писал для себя - удалять не буду)
ISR(TIMER1_COMPA_vect) // прерывание таймера 1
{
	// сюда мы будем попадать при срабатывании (в нашем случае единственного настроенного) таймера (работа таймера подробнее описана ниже)
	
	 // тут будем двигать змейку
	 if (dead) return; // если она не мертва
	 { // блок открыт, чтобы максимально рано "освободить" переменую coord (см. ниже). Зачем? нуу просто захотелось
		 // в coord мы щас положем координаты, на которые будет перемещена голова змейки
		 COORD coord;
		 
		 
		 
		 // вычисляем координаты в соответствии с направлением (увеличиваем или уменьшаем на 1 нужную коодинату)
		 if (direction == 0)
		 {
			 // также проверяем, не выйдет ли змейка за границы поля
			 // если выйдет, то перемещаем на противоположную сторону
			 if (body[0].X == WIDTH - 1)
			 {
				coord.X = 0;
			 }
			 else
			 {
				coord.X = body[0].X + 1;
			 }
			 coord.Y = body[0].Y;
		 }
		 else if (direction == 2)
		 {
			 if (body[0].X == 0)
			 {
				 coord.X = WIDTH - 1;
			 }
			 else
			 {
				 coord.X = body[0].X - 1;
			 }
			 coord.Y = body[0].Y;
		 }
		 else if (direction == 1)
		 {
			 if (body[0].Y == 0)
			 {
				 coord.Y = HEIGHT - 1;
			 }
			 else
			 {
				 coord.Y = body[0].Y - 1;
			 }
			 coord.X = body[0].X;
		 }
		 else
		 {
			 if (body[0].Y == HEIGHT - 1)
			 {
				 coord.Y = 0;
			 }
			 else
			 {
				 coord.Y = body[0].Y + 1;
			 }
			 coord.X = body[0].X;
		 }
		 
		 // заталкиваем новые координаты головы в начало массива
		 G2R2_UNSHIFT_COORD(body, &length, coord); // КОД И ОПИСАНИЕ ЭТОЙ И ТРЁХ ДРУГИХ ФУНКЦИЙ СМОТРЕТЬ НА ДРУГОМ ЛИСТЕ
	 }
	 
	 // и отрезаем хвост, сохраняя координаты отрезанного кусочка в last_pop
	 last_pop = G2R2_POP_COORD(body, &length);
	 
	 // проверка на столкновение с собой
	 for (unsigned char i = 1; i < length; ++i)
	 {
		 // если координаты головы, совпадают с координатами какой-то клетки тела (кроме себя, поэтому отсчёт с одного в предыдущей строке)
		if ((body[0].X == body[i].X) && (body[0].Y == body[i].Y))
		{
			// то надо сдвинуть змейку назад, т.к. выше мы её сдвинули, не смотря на препядствие
			// возвращаем конец на место
			G2R2_PUSH_COORD(body, &length, last_pop);
			// возвращаем голову на место
			G2R2_SHIFT_COORD(body, &length);
			// убиваем
			dead = TRUE;
		}
	 }
	 
	 // проверка на столкновение с яблоком: если координаты головы и яблока совпадают
	 if ((body[0].X == apple.X) && (body[0].Y == apple.Y))
	 {
		 // то мы двигаем яблоко на случайное место
		APPLE_MOVE:
		// делим случайное число на ширину(ниже на высоту) и берём остаток от деления, чтобы новая координата не выходила за границу поля
		apple.X = rand() % WIDTH;
		apple.Y = rand() % HEIGHT;
		
		for (unsigned char i = 0; i < length; ++i)
		{
			// если новые координаты яблока совпадают с координатами змейки - пробуем ещё раз
			if ((body[i].X == apple.X) && (body[i].Y == apple.Y))
			{
				goto APPLE_MOVE;
			}
		}
		
		// увеличиваем длину змейки
		G2R2_PUSH_COORD(body, &length, last_pop);
		
		// ускорение змейки:
		
		// таймер считает до числа, первая половина которого хранится в регистре OCR1AL, а вторая в OCR1AH (подробнее смотреть ниже, где настройка таймера)
		// это число беззнаковое, две половины по 8 бит
		
		// создадим OCR - беззнаковую переменную, длиной в 16 бит и скопируем туда число, до которого считает таймер
		unsigned int OCR = OCR1AL | (OCR1AH << 8);
		
		// мне больше всего понравилось, когда число уменьшалось на константу (а не на процент от себя, например)
		// по заметность\степень_ускорения число 4095 показалось мне самым удачным
		OCR -= 4095; // 16'000'000 Hz / 256 / 64 = 976 (это одна из тех строк, что я оставил для себя)
		
		// записываем число на своё место (в регистры, на которые смотрит таймер)
		OCR1AL = ((unsigned char *)&OCR)[0];
		OCR1AH = ((unsigned char *)&OCR)[1];
		
	 }
	 
	 // сдвинули змейку - сбрасываем key_pressed, чтобы разблокировать поворот
	 key_pressed = FALSE;
}

ISR(PCINT0_vect) // прерывание кнопок
{
	// сюда мы будем попадать при изменении логического состояния любой из кнопок (настройка такого поведения - ниже)
	
	// prevPINB будет хранить предыдущее логическое состояние кнопок
	// PINB - unsigned char, prevPINB - тоже, static, чтобы при выходе из обработчика прерывания значение сохранялось
	static unsigned char prevPINB = 0; // т.к. static, то 0 будет записан только при старте программы
	
	// если key_pressed установлен в "истина", то просто обновим prevPINB
	if (key_pressed) goto RET;
	
	// когда кнопка опускается, то логический уровень устанавливается в 0
	// если рассматривать PINB как число, то тогда оно уменьшается
	if ((PINB & 0b00111100) < (prevPINB & 0b00111100)) // т.е. "если хоть одна из кнопок опустилать"
	{
		//_delay_ms(30); // от дребезга кнопок // тут это не надо, т.к. несколько лишних нажатий на ту же кнопку ничего не изменят
		
		
		
		// тут мы уже уточняем, какая из кнопок была нажата (сравниваем конкретные биты)
		if ((prevPINB & 0b00000100) != (PINB & 0b00000100)) // влево
		{
			// если поворот будет не в обратную сторону (и если это поворот), то поворачиваем и устанавливаем key_pressed в "истина"
			if ((direction != 0) && (direction != 2)) { direction = 2; key_pressed = TRUE; }
		}
		else if ((prevPINB & 0b00001000) != (PINB & 0b00001000)) // вправо
		{
			if ((direction != 2) && (direction != 0)) { direction = 0; key_pressed = TRUE; }
		}
		else if ((prevPINB & 0b00010000) != (PINB & 0b00010000)) // вниз
		{
			if ((direction != 1) && (direction != 3)) { direction = 3; key_pressed = TRUE; }
		}
		else if ((prevPINB & 0b00100000) != (PINB & 0b00100000)) // вверх
		{
			if ((direction != 3) && (direction != 1)) { direction = 1; key_pressed = TRUE; }
		}
	}
	
	RET: prevPINB = PINB; // обновляем prevPINB
}

// SetPixel будет зажигать светодиод по указанным координатам хотябы на одну миллисекунду
void SetPixel(unsigned char X, unsigned char Y)
{
	PORTD = 0b00000000; // пока отключаем ток на всех анодах
	PORTC |= ~0b11000000; // и включаем на катодах
	PORTB |= ~0b11111100; // две строки, т.к. катоды разбросаны на два порта (т.е. надо работать с двумя регистрами)
	
	PORTD = (1 << X); // включаем ток на нужном аноде
	
	// выключаем ток на нужном катоде (и подключаем к земле)
	if (Y >= 6)
	{
		PORTB &= ~(1 << (Y - 6));
	}
	else
	{
		PORTC &= ~(1 << Y);
	}
	
	_delay_ms(1); // останавливаем микроконтроллер на одну миллисекунду
	//for (unsigned int i = 0; i != 0xffff; i++) asm("nop");
}

int main(void)
{
	// TCCR1 - регистр режима (сам 16-ти битный) // 1 - т.к. первый таймер (16-ти битный)
	// именно в B нужные биты // режим - по совпадению
	// для CTC без генератора надо оставить выключенными
	// WGM10(Waveform Generator M?odulation), WGM11 и WGM13, а WGM12 включить (судя по таблице в даташите)
	
	// устанавливаем режим таймера - по совпадению. т.е. он будет срабатывать каждый раз, когда досчитает до некоторого числа
	TCCR1B |= (1 << WGM12);
	
	// TIMSK - timer mask
	// если в этот регистр ничего не забить, то таймер никогда не включится
	// OCIE1A - разрешение прерываний по совпадению с OCR1A
	
	// это число будет в OCR1A
	TIMSK1 |= (1 << OCIE1A);
	
	// число (в двух регистрах) на котором будем сбрасывать таймер (т.к. CTC)
	// 16'000'000 Hz / 256 = 0b1111'0100'0010'0100  около 60'000
	//OCR1AH = 0b11110100;
	//OCR1AL = 0b00100100;
	
	// OCR1A хранится в двух регистрах. устанавливаю максивальное значение, чтобы был больший потенциал, куда замедляться
	OCR1AH = 0b11111111;
	OCR1AL = 0b11111111;
	
	// включим делитель
	// CS№n - Clock Select bit (№ таймера)
	TCCR1B |= (1 << CS12); // делитель 256 // т.е. таймер будет срабатывать только 1 раз на 256 совпадений с OCR1A
	
	// включаем прерывания для кнопок
	PCICR |= (1 << PCIE0); // на порту B;
	PCMSK0 |= 0b00111100; // второй, 3, четвёртой и пятой ногах
	
	
	// настройка ножек
	
	DDRD = 0b11111111; // аноды - на выход
	PORTD = 0b00000000; // пока выкл
	
	DDRC |= 0b00111111; // катоды 0 - 5 на выход // когда на вход - к земле не притянуть
	DDRB |= 0b00000011; // катоды 6 и 7 на выход
	PORTC &= 0b11000000; // тут тоже пока выключу // катоды 0 - 5
	PORTB &= 0b11111100; // и 6 - 7
	
	DDRB &= 0b11000011; // кнопки на вход
	PORTB |= 0b00111100; // подтягиваем к ним резисторы на 20-50 килоОм
	
	// srand() надо бы сделать, но у меня не получилось по-быстрому найти случайность в шуме, через НАЖМИТЕ СТАРТ - не хочу
	// а через энергонезависимую память (EEPROM) было бы сложно и долго делать,
	// а потом ведь ещё объяснить надо, так что решил пока не делать. (после зачётов - обязательно, т.к. интересно)
	
	// стартовая позиция яблока
	apple.X = rand() % WIDTH; // подробнее около строки 144
	apple.Y = rand() % HEIGHT;
	
	// set interrupt // стартуем(разрешаем) прерывания
	sei();
	
	unsigned char i; // unsigned char, как и length
    while (TRUE)
    {
		// тут будем зажигать и тушить светодиоды
		
		//пробегаем на телу змейки
		for (i = 0; i < length; ++i)
		{
			// X и Y переданы наоборот, чтобы повернуть изображение на 90 градусов.
			// это надо, т.к. при составлении схемы я забил на это, зная, что смогу повернуть програмно
			SetPixel(body[i].Y, body[i].X);
		}
		
		// и не забываем про яблоко
		SetPixel(apple.Y, apple.X);
    }
}
